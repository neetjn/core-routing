{"version":3,"sources":["../src/memoize-decorator.ts","config.ts","router.ts"],"names":[],"mappings":"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","file":"router.js","sourceRoot":"../src","sourcesContent":["export function Memoize(hashFunction?: (...args: any[]) => any) {\n\treturn (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => {\n\n\t\tif (descriptor.value != null) {\n\t\t\tdescriptor.value = getNewFunction(descriptor.value, hashFunction);\n\t\t} else if (descriptor.get != null) {\n\t\t\tdescriptor.get = getNewFunction(descriptor.get, hashFunction);\n\t\t} else {\n\t\t\tthrow 'Only put a Memoize() decorator on a method or get accessor.';\n\t\t}\n\n\n\t};\n}\n\nlet counter = 0;\nfunction getNewFunction(originalMethod: () => void, hashFunction?: (...args: any[]) => any) {\n\tconst identifier = ++counter;\n\n\t// The function returned here gets called instead of originalMethod.\n\treturn function (...args: any[]) {\n\t\tconst propValName = `__memoized_value_${identifier}`;\n\t\tconst propMapName = `__memoized_map_${identifier}`;\n\n\t\tlet returnedValue: any;\n\n\t\tif (hashFunction || args.length > 0) {\n\n\t\t\t// Get or create map\n\t\t\tif (!this.hasOwnProperty(propMapName)) {\n\t\t\t\tObject.defineProperty(this, propMapName, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: new Map<any, any>()\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet myMap: Map<any, any> = this[propMapName];\n\n\t\t\tlet hashKey: any;\n\n\t\t\tif (hashFunction) {\n\t\t\t\thashKey = hashFunction.apply(this, args);\n\t\t\t} else {\n\t\t\t\thashKey = args[0];\n\t\t\t}\n\n\t\t\tif (myMap.has(hashKey)) {\n\t\t\t\treturnedValue = myMap.get(hashKey);\n\t\t\t} else {\n\t\t\t\treturnedValue = originalMethod.apply(this, args);\n\t\t\t\tmyMap.set(hashKey, returnedValue);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (this.hasOwnProperty(propValName)) {\n\t\t\t\treturnedValue = this[propValName];\n\t\t\t} else {\n\t\t\t\treturnedValue = originalMethod.apply(this, args);\n\t\t\t\tObject.defineProperty(this, propValName, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: returnedValue\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn returnedValue;\n\t};\n}\n","import { IConfig } from './interfaces/config';\n\nexport const Config: IConfig = {\n  settings: {\n    hash: '#!',\n  },\n  regex: {\n    settings: {\n      default: /[a-zA-Z0-9]/g,\n      href: /(www|http:|https:)+[^\\s]+[\\w]/g,\n    },\n    routes: {\n      variables: /(:(?!qargs)[a-zA-Z]*)/g,\n    },\n  },\n  intervals: {\n    start: 10,\n    listener: 250,\n  }\n};\n","import { Memoize } from 'typescript-memoize';\nimport {\n  IObject,\n  IRouterClient,\n  IRouterToolsResult,\n  IRouterToolsDetails,\n  IRouterTools,\n  IRouterArgs,\n  IRouter\n} from './interfaces/router';\nimport { IRouterLocation } from './interfaces/event';\nimport { IConfig } from './interfaces/config';\nimport { Config } from './config';\n\n// TODO: add documentation\n\nclass RouterTools implements IRouterTools {\n  public config: IConfig;\n\n  constructor (config: IConfig) {\n    this.config = config;\n  }\n\n  @Memoize()\n  inspect (route: string, source: string) : IRouterToolsResult {\n    let parts = route.split(this.config.settings.hash);\n    let query = '';\n    let fragment = '';\n\n    if (parts.length === 2) {\n      const trailing = parts.slice(-1)[0];\n      if (trailing.split('#').length > 1) {\n        // provide fragment\n        fragment = trailing.split('#')[1];\n      }\n      // provide query arguments\n      query = trailing.split('?')[0].split('#')[0];\n      // remove query arguments + fragment from route\n      // remove expected empty first element\n      parts = parts.join('').split('?')[0].split('/').slice(1);\n    } else {\n      // default to route \"/\"\n      parts = ['/'];\n    }\n\n    return {\n      route: parts,\n      query,\n      fragment,\n      // split source path and remove expected empty first element\n      source: source.split('/').slice(1)\n    };\n  }\n\n  @Memoize()\n  match (route: string, source: string) : boolean {\n    const result = this.inspect(route, source);\n\n    if (result.route.length === result.source.length) {\n      for (const i in result.source) {\n        if (!(result.source[i].startsWith(':') || result.route[i] === result.source[i])) {\n          return false;\n        }\n      }\n      console.log(`Matched: \"${route}\" with \"${source}\"`);\n      return true;\n    }\n\n    return false;\n  }\n\n  @Memoize()\n  process (route: string, source: string) : IRouterToolsDetails {\n    const result = this.inspect(route, source);\n    const variables: IObject = {};\n    const args: IObject = {};\n\n    result.source.forEach((part, i) => {\n      if (part.startsWith(':')) {\n        const name = part.slice(1);\n        const value = result.route[i];\n        variables[name] = value;\n      }\n    });\n\n    if (result.query) {\n      // deconstruct provided query string\n      const query = result.query.split('&');\n      query.forEach(arg => {\n        const temp: Array<string> = arg.split('=');\n        if (temp.length === 2) {\n          // assign query string arguments\n          args[temp[0]] = temp[1];\n        }\n      });\n    }\n\n    return {\n      result,\n      variables,\n      args\n    };\n  }\n}\n\nclass Router implements IRouter {\n  public config: IConfig;\n  public running: boolean;\n  public legacySupport: boolean;\n  public listenerKey?: number;\n  public client?: IRouterClient;\n\n  public $tools: IRouterTools;\n  public $previous: IRouterLocation;\n\n  constructor (args: IRouterArgs) {\n    this.config = Object.assign(args.config || {}, Config);\n    this.client = args.client;\n    this.running = false;\n    this.legacySupport = !('onpopstate' in window);\n    this.$tools = new RouterTools(this.config);\n    this.$previous = {\n      path: '',\n      hash: '',\n      href: ''\n    };\n  }\n\n  get $location () {\n    let path = '';\n    const hash = window.location.hash;\n    if (hash.split(this.config.settings.hash).length > 1) {\n      path = hash.split(this.config.settings.hash)[1];\n      if (!path.startsWith('/')) {\n        path = `/${path}`;\n      }\n    }\n    return {\n      path: path,\n      hash: hash,\n      href: window.location.href\n    };\n  }\n\n  watch () {\n    // TODO: make ambiguous, must be able to run only on route change w/ interval\n\n    if (this.running) {\n      // let navigated =\n      if (this.client && this.client.onNavigate) {\n        this.client.onNavigate({\n          $tools: this.$tools,\n          location: this.$location,\n          previous: this.$previous,\n        });\n\n        this.$previous = this.$location;\n      }\n    }\n  }\n\n  start () {\n    if (!this.running) {\n      this.running = true;\n      if (this.client && this.client.onStart) {\n        this.client.onStart({\n          $tools: this.$tools,\n          location: this.$location\n        });\n      }\n      if (this.legacySupport) {\n        setInterval(this.watch, this.config.intervals.listener);\n      } else {\n        window.addEventListener('popstate', this.watch.bind(this));\n      }\n    }\n  }\n\n  stop () {\n    // TODO: ensure stop works as expected when binding watcher\n    if (this.running) {\n      this.running = false;\n      if (this.client && this.client.onStop) {\n        this.client.onStop({\n          $tools: this.$tools,\n        });\n      }\n      if (this.legacySupport) {\n        window.removeEventListener('popstate', this.watch);\n      } else {\n        window.clearInterval(this.listenerKey);\n      }\n    }\n  }\n}\n\nmodule.exports = Router;\n"]}