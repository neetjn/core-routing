{"version":3,"sources":["../src/memoize-decorator.ts","config.ts","router.ts"],"names":[],"mappings":"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","file":"router.prod.js","sourceRoot":"../src","sourcesContent":["export function Memoize(hashFunction?: (...args: any[]) => any) {\n\treturn (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => {\n\n\t\tif (descriptor.value != null) {\n\t\t\tdescriptor.value = getNewFunction(descriptor.value, hashFunction);\n\t\t} else if (descriptor.get != null) {\n\t\t\tdescriptor.get = getNewFunction(descriptor.get, hashFunction);\n\t\t} else {\n\t\t\tthrow 'Only put a Memoize() decorator on a method or get accessor.';\n\t\t}\n\n\n\t};\n}\n\nlet counter = 0;\nfunction getNewFunction(originalMethod: () => void, hashFunction?: (...args: any[]) => any) {\n\tconst identifier = ++counter;\n\n\t// The function returned here gets called instead of originalMethod.\n\treturn function (...args: any[]) {\n\t\tconst propValName = `__memoized_value_${identifier}`;\n\t\tconst propMapName = `__memoized_map_${identifier}`;\n\n\t\tlet returnedValue: any;\n\n\t\tif (hashFunction || args.length > 0) {\n\n\t\t\t// Get or create map\n\t\t\tif (!this.hasOwnProperty(propMapName)) {\n\t\t\t\tObject.defineProperty(this, propMapName, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: new Map<any, any>()\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet myMap: Map<any, any> = this[propMapName];\n\n\t\t\tlet hashKey: any;\n\n\t\t\tif (hashFunction) {\n\t\t\t\thashKey = hashFunction.apply(this, args);\n\t\t\t} else {\n\t\t\t\thashKey = args[0];\n\t\t\t}\n\n\t\t\tif (myMap.has(hashKey)) {\n\t\t\t\treturnedValue = myMap.get(hashKey);\n\t\t\t} else {\n\t\t\t\treturnedValue = originalMethod.apply(this, args);\n\t\t\t\tmyMap.set(hashKey, returnedValue);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (this.hasOwnProperty(propValName)) {\n\t\t\t\treturnedValue = this[propValName];\n\t\t\t} else {\n\t\t\t\treturnedValue = originalMethod.apply(this, args);\n\t\t\t\tObject.defineProperty(this, propValName, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: false,\n\t\t\t\t\tvalue: returnedValue\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn returnedValue;\n\t};\n}\n","import { IConfig } from './interfaces/config';\n\nexport const Config: IConfig = {\n  settings: {\n    hash: '#!',\n    wildcard: '*'\n  },\n  regex: {\n    settings: {\n      default: /[a-zA-Z0-9]/g,\n      href: /(www|http:|https:)+[^\\s]+[\\w]/g\n    },\n    routes: {\n      variables: /(:(?!qargs)[a-zA-Z]*)/g\n    }\n  },\n  intervals: {\n    start: 10,\n    listener: 250\n  }\n};\n","import { Memoize } from 'typescript-memoize';\nimport {\n  IObject,\n  IRouterClient,\n  IRouterToolsResult,\n  IRouterToolsDetails,\n  IRouterTools,\n  IRouterArgs,\n  IRouter\n} from './interfaces/router';\nimport { IRouterLocation } from './interfaces/event';\nimport { IConfig } from './interfaces/config';\nimport { Config } from './config';\n\n// Provider for generating memoize cache keys for router tools.\n// @param {string} route\n// @param {string} source\n// @returns {string}\nconst memoizeRTKey = (route: string, source: string): string => `${route}:${source}`;\n\nclass RouterTools implements IRouterTools {\n  public config: IConfig;\n\n  constructor (config: IConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Provides basic information for both a route and source path.\n   * @param {string} route - Route for inspection.\n   * @param {string} source - Source path.\n   * @returns {IRouterToolsResult}\n\n    inspect('/user/1/profile?strict=true#header', '/user/:userId/profile') =>\n\n      {\n        route: ['user', '1', 'profile'],\n        query: 'strict=true',\n        fragment: 'header',\n        source: ['user', ':userId', 'profile']\n      }\n\n   */\n  @Memoize(memoizeRTKey)\n  inspect (route: string, source: string): IRouterToolsResult {\n    let parts;\n    let query = '';\n    let fragment = '';\n\n    // skip computations on empty path\n    if (route !== '/') {\n      // split route path\n      parts = route.split('/');\n      // remove trailing from path\n      const trailing = parts.slice(-1)[0];\n      if (trailing.split('#').length > 1) {\n        // provide fragment\n        fragment = trailing.split('#')[1];\n      }\n      // provide query arguments\n      if (trailing.indexOf('?') !== -1) {\n        query = trailing.split('?')[1].split('#')[0];\n      }\n      // remove query arguments + fragment from route\n      // remove expected empty first element\n      parts = parts\n        .join('/')\n        .split('?')[0]\n        .split('/')\n        .slice(1);\n    } else {\n      // default to route \"/\"\n      parts = ['/'];\n    }\n\n    return {\n      route: parts,\n      query,\n      fragment,\n      // split source path and remove expected empty first element\n      source: source !== '/' ? source.split('/').slice(1) : [source]\n    };\n  }\n\n  /**\n   * Match a given route with a source path.\n   * @param route - Route to match against source path.\n   * @param source - Source path to match against route.\n   * @returns {boolean}\n\n    match('/user/search/groups', '/user/:userId/profile') => false\n    match('/user/1/profile', '/user/:userId/profile') => true\n    match('/some/route/yo', '*') => true\n\n   */\n  @Memoize(memoizeRTKey)\n  match (route: string, source: string): boolean {\n    // skip computation and match if path is wildcard\n    if (source !== this.config.settings.wildcard) {\n      const result = this.inspect(route, source);\n      // don't even bother computations if length mismatch in path\n      if (result.route.length === result.source.length) {\n        for (const i in result.source) {\n          // fail if not variable as denoted by source and chunk mismatch\n          // result.source => ['user', ':userId', 'profile']\n          // result.route => ['user', 'search', 'groups']\n          // result.source[3] != result.route[3]\n          if (\n            !result.source[i].startsWith(':') &&\n            result.route[i] !== result.source[i]\n          ) {\n            return false;\n          }\n        }\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Provides detailed information for both a route and source path.\n   * @param route - Route to process.\n   * @param source - Source path to process.\n   * @returns {boolean}\n\n    process('/user/1/profile?strict=true#header', '/user/:userId/profile') =>\n\n      {\n        result: {\n          route: ['user', '1', 'profile'],\n          query: 'strict=true',\n          fragment: 'header',\n          source: ['user', ':userId', 'profile']\n        },\n        variables: {\n          userId: 1\n        }\n        args: {\n          strict: 'true'\n        }\n      }\n\n   */\n  @Memoize(memoizeRTKey)\n  process (route: string, source: string): IRouterToolsDetails {\n    const result = this.inspect(route, source);\n    const variables: IObject = {};\n    const args: IObject = {};\n\n    result.source.forEach((part, i) => {\n      if (part.startsWith(':')) {\n        const name = part.slice(1);\n        const value = result.route[i];\n        variables[name] = value;\n      }\n    });\n\n    if (result.query) {\n      // deconstruct provided query string\n      const query = result.query.split('&');\n      query.forEach(arg => {\n        const temp: Array<string> = arg.split('=');\n        if (temp.length === 2) {\n          // assign query string arguments\n          args[temp[0]] = temp[1];\n        }\n      });\n    }\n\n    return {\n      result,\n      variables,\n      args\n    };\n  }\n}\n\nclass Router implements IRouter {\n  public config: IConfig;\n  public running: boolean;\n  public legacySupport: boolean;\n  public listenerKey?: number;\n  public client?: IRouterClient;\n\n  public $tools: IRouterTools;\n  public $previous: IRouterLocation;\n\n  constructor (args: IRouterArgs) {\n    this.config = Object.assign(args.config || {}, Config);\n    this.client = args.client;\n    this.running = false;\n    // set to legacy mode if target HTML5 history api event not detected\n    this.legacySupport = !('onpopstate' in window);\n    this.$tools = new RouterTools(this.config);\n    this.$previous = {\n      path: '',\n      hash: '',\n      href: ''\n    };\n  }\n\n  /**\n   * Get detailed window location info.\n   * @returns {IRouterLocation}\n   */\n  get $location (): IRouterLocation {\n    let path = '';\n    const hash = window.location.hash;\n    if (hash.split(this.config.settings.hash).length > 1) {\n      path = hash.split(this.config.settings.hash)[1];\n      if (!path.startsWith('/')) {\n        path = `/${path}`;\n      }\n    }\n    return {\n      path: path,\n      hash: hash,\n      href: window.location.href\n    };\n  }\n\n  /** Subroutine for handling router navigation events */\n  watch () {\n    if (this.running) {\n      // if legacy support detected and location unchanged between previous and current cycle\n      // skip trigger for navigation event\n      if (\n        this.legacySupport &&\n        JSON.stringify(this.$location) === JSON.stringify(this.$previous)\n      ) {\n        // bypass onNavigate trigger\n        return;\n      }\n      if (this.client && this.client.onNavigate) {\n        this.client.onNavigate({\n          $tools: this.$tools,\n          location: this.$location,\n          previous: this.$previous\n        });\n      }\n      this.$previous = this.$location;\n    }\n  }\n\n  /** Start router listener on navigation events */\n  start () {\n    if (!this.running) {\n      // toggle routing capabilities\n      this.running = true;\n      // initialize default previous location\n      this.$previous = this.$location;\n      if (this.client && this.client.onStart) {\n        this.client.onStart({\n          $tools: this.$tools,\n          location: this.$location\n        });\n      }\n      if (this.legacySupport) {\n        // if legacy support is detected, set listener on interval\n        setInterval(this.watch.bind(this), this.config.intervals.listener);\n      } else {\n        window.addEventListener('popstate', this.watch.bind(this));\n      }\n    }\n  }\n\n  /** Halt router listener on navigation events */\n  stop () {\n    if (this.running) {\n      // toggle routing capabilities\n      this.running = false;\n      if (this.client && this.client.onStop) {\n        this.client.onStop({\n          $tools: this.$tools,\n          location: this.$location\n        });\n      }\n      if (this.legacySupport) {\n        window.removeEventListener('popstate', this.watch);\n      } else {\n        window.clearInterval(this.listenerKey);\n      }\n    }\n  }\n}\n\nmodule.exports = Router;\n"]}